#!/usr/bin/env bash

# Security: Enable strict error handling
set -euo pipefail

# Source security utilities
if [ -f "$(dirname "$0")/git_at_cmds/_security.sh" ]; then
    source "$(dirname "$0")/git_at_cmds/_security.sh"
fi

version() {
    cat << 'EOF'
GitAT - Git Workflow Management Tool v1.0.1

A comprehensive Git plugin for secure workflow management with:
✅ Security-first design with input validation
✅ Semantic versioning management
✅ Branch workflow automation
✅ Release management tools
✅ Comprehensive help system

For help: git @ --help
For command help: git @ <command> --help

EOF
}

usage() {
    cat << 'EOF'

Usage:
================================================================================
git @ <subcommand> [<options>]

All subcommands support --help for detailed information:
  git @ <subcommand> --help

Available Subcommands:
================================================================================

Configuration & Information
---------------------------
info                    # Show comprehensive GitAT status
product [<name>]        # Set/get product name
feature [<name>]        # Set/get feature name  
version [options]       # Manage semantic versioning
branch [<name>]         # Set/get working branch
issue [<id>]            # Set/get issue identifier

Workflow Commands
-----------------
save [<message>]        # Securely save changes with validation
work                    # Switch to working branch with stash management
wip [options]           # Manage work-in-progress branch state

Release Management
------------------
release [options]       # Create releases with version bumping
squash [options] <branch> # Clean commit history

Utility Commands
----------------
_label [<label>]        # Manage commit labels [project.feature.issue]
_trunk [<branch>]       # Set/get base branch (develop/master)
_path                   # Get repository root path
_id                     # Generate project identifier
_go                     # Initialize GitAT for new repository

Repository Management
---------------------
initlocal <url> <name>  # Initialize new repository with branch structure
ignore <pattern>        # Add patterns to .gitignore

Status & Analysis
-----------------
changes                 # Show uncommitted changes
logs                    # Show recent commit history
hash                    # Show detailed branch status and relationships

Branch Management
-----------------
master                  # Switch to master branch with stash
root                    # Switch to trunk branch with stash
sweep                   # Clean up merged branches

Security Features
-----------------
✅ Input validation against dangerous patterns
✅ Path validation and restriction
✅ Safe command execution
✅ Security logging and monitoring
✅ Branch protection and confirmation prompts

For detailed help on any command:
  git @ <command> --help

Examples:
  git @ info                    # Show current status
  git @ product gitAT           # Set product name
  git @ feature user-auth       # Set feature name
  git @ save "Add login"        # Save changes securely
  git @ work                    # Switch to working branch
  git @ release -m              # Create minor release

EOF
}

main() {
    if [ "$#" -lt 1 ]; then
        usage; exit 1
    fi

    local subcommand="$1"; shift

    case $subcommand in
        "-h"|"--help")
            usage; exit 0
            ;;
        "-v"|"--version")
            version; exit 0
            ;;
        "-a"|"--all"|"a"|"all")
            "$0" info; exit 0
            ;;
    esac

    # Get the directory where this script is located
    SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
    
    # If this is a symbolic link, follow it to find the actual script location
    if [ -L "$0" ]; then
        SCRIPT_DIR="$(cd "$(dirname "$(readlink "$0")")" && pwd)"
    fi
    
    # Check if the subcommand file exists
    if [ ! -e "$SCRIPT_DIR/git_at_cmds/$subcommand.sh" ]; then
        git "$subcommand" "$@"; exit 1
    fi

    # Load the subcommand script
    source "$SCRIPT_DIR/git_at_cmds/$subcommand.sh"

    # Check if the function exists
    local cmdtype=$(type -t "cmd_$subcommand")
    if [ "$cmdtype" != "function" ]; then
        echo "Error: Function cmd_$subcommand not found in $SCRIPT_DIR/git_at_cmds/$subcommand.sh" >&2
        usage; exit 1
    fi

    # Call the function with all arguments
    cmd_"$subcommand" "$@"
}

main "$@"